"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.module = void 0;

var _reactNative = require("react-native");

var _constants = require("./constants");

var _utils = require("./utils");

const RNP = _reactNative.NativeModules.RNPermissions;

function grantedToStatus(granted) {
  return granted ? _constants.RESULTS.GRANTED : _constants.RESULTS.DENIED;
}

function coreStatusToStatus(status) {
  switch (status) {
    case 'granted':
      return _constants.RESULTS.GRANTED;

    case 'denied':
      return _constants.RESULTS.DENIED;

    case 'never_ask_again':
      return _constants.RESULTS.BLOCKED;

    default:
      return _constants.RESULTS.UNAVAILABLE;
  }
}

async function openSettings() {
  await RNP.openSettings();
}

async function check(permission) {
  if (!RNP.available.includes(permission)) {
    return _constants.RESULTS.UNAVAILABLE;
  }

  if (await RNP.isNonRequestable(permission)) {
    return _constants.RESULTS.BLOCKED;
  }

  const granted = await _reactNative.PermissionsAndroid.check(permission);
  return grantedToStatus(granted);
}

async function request(permission, rationale) {
  if (!RNP.available.includes(permission)) {
    return _constants.RESULTS.UNAVAILABLE;
  }

  if (await RNP.isNonRequestable(permission)) {
    return _constants.RESULTS.BLOCKED;
  }

  const status = coreStatusToStatus((await _reactNative.PermissionsAndroid.request(permission, rationale)));

  if (status === _constants.RESULTS.BLOCKED) {
    await RNP.setNonRequestable(permission);
  }

  return status;
}

async function splitByUsability(permissions) {
  const unusables = {};
  const usables = [];
  const blocklist = await RNP.getNonRequestables();

  for (let index = 0; index < permissions.length; index++) {
    const permission = permissions[index];

    if (blocklist.includes(permission)) {
      unusables[permission] = _constants.RESULTS.BLOCKED;
      continue;
    }

    if (!RNP.available.includes(permission)) {
      unusables[permission] = _constants.RESULTS.UNAVAILABLE;
      continue;
    }

    usables.push(permission);
  }

  return {
    unusables,
    usables
  };
}

function checkNotifications() {
  return RNP.checkNotifications();
}

async function checkMultiple(permissions) {
  const dedup = (0, _utils.uniq)(permissions);
  const {
    unusables: output,
    usables
  } = await splitByUsability(dedup);
  await Promise.all(usables.map(async permission => {
    const granted = await _reactNative.PermissionsAndroid.check(permission);
    output[permission] = grantedToStatus(granted);
  }));
  return output;
}

async function requestMultiple(permissions) {
  const toSetAsNonRequestable = [];
  const dedup = (0, _utils.uniq)(permissions);
  const {
    unusables: output,
    usables
  } = await splitByUsability(dedup);
  const statuses = await _reactNative.PermissionsAndroid.requestMultiple(usables);

  for (const permission in statuses) {
    if (statuses.hasOwnProperty(permission)) {
      const status = coreStatusToStatus(statuses[permission]);
      output[permission] = status;
      status === _constants.RESULTS.BLOCKED && toSetAsNonRequestable.push(permission);
    }
  }

  if (toSetAsNonRequestable.length > 0) {
    await RNP.setNonRequestables(toSetAsNonRequestable);
  }

  return output;
}

const _module = {
  openSettings,
  check,
  request,
  checkNotifications,
  requestNotifications: checkNotifications,
  checkMultiple,
  requestMultiple
};
exports.module = _module;
//# sourceMappingURL=module.android.js.map